// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use borsh::to_vec;
use methods::{FIBONACCI_ELF, FIBONACCI_ID};
use risc0_zkvm::{compute_image_id, default_prover, ExecutorEnv, ProverOpts, VerifierContext};
use std::fs::File;
use std::io::Write;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    let input: u32 = 15;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let receipt = default_prover()
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            FIBONACCI_ELF,
            &ProverOpts::groth16(),
        )
        .expect("Proving failed")
        .receipt;

    // extract the receipt.
    // let receipt = prove_info.receipt;
    let journal = receipt.journal.bytes.clone();
    println!("{:#?}", receipt);

    println!("{}", std::any::type_name_of_val(&receipt));
    println!("{:#?}", journal);

    let output: u32 = receipt.journal.decode().unwrap();
    println!("{:#?}", output);
    // assert_eq!(input, output);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(FIBONACCI_ID).unwrap();

    // serialize the receipt into bytes
    let receipt_bytes = to_vec(&receipt).expect("Serialization failed");
    println!("{:?}", receipt_bytes);

    // compute the image ID
    let image_id_digest = compute_image_id(&FIBONACCI_ELF).expect("Compute Image ID failed");
    let image_id_bytes = image_id_digest.as_bytes();
    println!("{:?}", image_id_bytes);

    // save imageID bytes + receipt bytes to file
    let mut receipt_file = File::create("image_data.bin").expect("Couldn't create image_data.bin");
    receipt_file
        .write_all(&receipt_bytes)
        .expect("Couldn't write receipt data to bin");

    let mut image_id_file = File::create("image_id.bin").expect("Couldn't create image_id.bin");
    image_id_file
        .write_all(&image_id_bytes)
        .expect("Couldn't write image ID to bin")
}
